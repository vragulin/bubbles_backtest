# -*- coding: utf-8 -*-
"""multi-7-agent model with sims public.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pN7yjsYaY-C4Fu-z8WzEfJMZkrYYsy__

# Who Killed the Random Walk?
## How Extrapolators Create Booms, Busts, Trends, and Opportunity
### Victor Haghani, Vladimir Ragulin, Jeffrey Rosenbluth, James White
A multi-agent stock market simulation.

## Imports

Standard library and third-party imports used throughout the notebook.
"""

# @title
from __future__ import annotations
from dataclasses import dataclass, field, replace

import numpy as np
try:
    from IPython.display import display
except ImportError:
    def display(df):
        print(df)
        print()

"""## Configuration

Immutable dataclasses that define every tunable parameter of the
simulation. `SimulationParams` is the top-level container; it embeds all sub-configs
and provides convenience properties and builder methods.

**Classes:**
- `InvestorFractions` -- population weight of each investor type
- `RealRateParams` -- mean-reverting real rate process
- `ExtrapParams` -- extrapolator lookback weights and squeeze function
- `StmrParams` -- short-term mean-reversion investor
- `MomentumParams` -- momentum investor
- `StaticParams` -- constant-allocation investor
- `ValmoParams` -- value + momentum hybrid investor
- `IssuanceParams` -- share issuance / buyback thresholds and rates
- `GridParams` -- clearing price grid search bounds and resolution
- `AnticipParams` -- anticipatory (exogenous) investor
- `SimulationParams` -- master config embedding all of the above
"""

# @title
# Immutable configuration dataclasses for the simulation.

@dataclass(frozen=True)
class InvestorFractions:
    static_frac: float = 0.33332
    cashflow_frac: float = 0.33332
    extrap_frac: float = 0.33333
    stmr_frac: float = 0.00001
    mmntm_frac: float = 0.00001
    valmo_frac: float = 0.00001


@dataclass(frozen=True)
class RealRateParams:
    target: float = 0.02
    mr_speed: float = 0.10
    vol: float = 0.20
    min_rate: float = -0.02
    earnings_corr: float = 0.5
    init: float = 0.02
    bond_maturity: float = 0.0  # in years, 0 means no duration


@dataclass(frozen=True)
class ExtrapParams:
    weights: tuple = (0.30, 0.25, 0.20, 0.15, 0.10)
    center: float = 0.04
    max_dev: float = 0.03
    squeeze: float = 0.1
    pct_monthly: float = 0.5

    def pct_current(self, periods_per_year: int) -> float:
        return 1 - (1 - self.pct_monthly) ** (12 / periods_per_year)


@dataclass(frozen=True)
class StmrParams:
    lookback_time: float = 1 / 48  # changed from 1/12 to 1/48
    baseline: float = 0.5
    deviation: float = 1 / 6
    numb_sigmas_max_dev: float = 2.5

    def lookback_periods(self, periods_per_year: int) -> int:
        return int(self.lookback_time * periods_per_year)

    def max_dev_var(self, stock_vol_assumed: float) -> float:
        """Maximum deviation variance threshold."""
        return self.lookback_time * (self.numb_sigmas_max_dev * stock_vol_assumed) ** 2


@dataclass(frozen=True)
class MomentumParams:
    lookback_time: float = 1.0  # in years
    baseline: float = 0.5
    deviation: float = 1 / 6

    def lookback_periods(self, periods_per_year: int) -> int:
        return int(self.lookback_time * periods_per_year)


@dataclass(frozen=True)
class StaticParams:
    baseline: float = 0.5


@dataclass(frozen=True)
class ValmoParams:
    lookback_time: float = 1.0  # in years
    baseline: float = 0.6
    momentum_weight: float = 1 / 3
    rp_max: float = 2 / 3

    def lookback_periods(self, periods_per_year: int) -> int:
        return int(self.lookback_time * periods_per_year)


@dataclass(frozen=True)
class IssuanceParams:
    issuance_threshold: float = 0.01
    buyback_threshold: float = 0.12
    issuance_rate: float = 0.0
    buyback_rate: float = 0.0


@dataclass(frozen=True)
class GridParams:
    max_price_move: float | None = None  # computed if None
    max_grid_move: float | None = None  # computed if None
    step_size: float = 0.01
    anticip_step_size: float = 0.02

    def resolve(self, periods_per_year: int) -> GridParams:
        """Return a copy with max_price_move and max_grid_move filled in."""
        if self.max_price_move is not None and self.max_grid_move is not None:
            return self
        targets = {1: 0.5, 4: 0.25, 12: 0.15, 48: 0.08, 240: 0.04}
        closest = min(targets.keys(), key=lambda x: abs(x - periods_per_year))
        mpm = targets[closest]
        mgm = min(24 * mpm, 0.98)
        return replace(self, max_price_move=mpm, max_grid_move=mgm)


@dataclass(frozen=True)
class AnticipParams:
    baseline: float = 0.6
    risk_aversion: float = 2.0
    initial_wealth: float = 1.0


@dataclass(frozen=True)
class SimulationParams:
    periods_per_year: int = 240
    years: int = 40
    init_exp_ret: float = 0.05
    init_earnings_yield: float = 0.05
    earnings_vol: float = 0.1
    payout_ratio: float = 0.333
    max_excess_earnings_growth: float = 100.0  # above safe asset rate
    crra: float = 3.0
    stock_vol_assumed: float = 0.16
    inout_vol: float = 0.06
    short_max: float = 0.0
    lev_max: float = 1.0
    include_anticip: bool = True

    fractions: InvestorFractions = field(default_factory=InvestorFractions)
    real_rate: RealRateParams = field(default_factory=RealRateParams)
    extrap: ExtrapParams = field(default_factory=ExtrapParams)
    stmr: StmrParams = field(default_factory=StmrParams)
    momentum: MomentumParams = field(default_factory=MomentumParams)
    static: StaticParams = field(default_factory=StaticParams)
    valmo: ValmoParams = field(default_factory=ValmoParams)
    issuance: IssuanceParams = field(default_factory=IssuanceParams)
    grid: GridParams = field(default_factory=GridParams)
    anticip: AnticipParams = field(default_factory=AnticipParams)

    @property
    def n_periods(self) -> int:
        return self.periods_per_year * self.years

    @property
    def vol_sq(self) -> float:
        return self.stock_vol_assumed**2

    def resolved_grid(self) -> GridParams:
        return self.grid.resolve(self.periods_per_year)

    def with_fractions(self, **kwargs) -> SimulationParams:
        return replace(self, fractions=replace(self.fractions, **kwargs))

    def with_real_rate(self, **kwargs) -> SimulationParams:
        return replace(self, real_rate=replace(self.real_rate, **kwargs))

    def with_extrap(self, **kwargs) -> SimulationParams:
        return replace(self, extrap=replace(self.extrap, **kwargs))

    def with_grid(self, **kwargs) -> SimulationParams:
        return replace(self, grid=replace(self.grid, **kwargs))

"""## State Types & Initialization

Mutable dataclasses that hold the evolving state of the market and each investor.
`generate_random_numbers` draws all shocks up front so simulations are reproducible
from a single seed. `initialize` builds the 5-year price history and sets the initial
wealth and share allocation for every investor type.

**Classes:**
- `MarketState` -- price, earnings, real rate, and related time series
- `InvestorState` -- per-investor wealth and share holdings
- `RandomShocks` -- pre-generated correlated shock vectors

**Functions:**
- `generate_random_numbers(params, seed)` -- draw all random shocks for the simulation
- `initialize(params)` -- create initial `MarketState` and investor `dict`
"""

# @title
# Mutable state types, random number generation, and initialization.

@dataclass
class MarketState:
    price_history: np.ndarray       # (5 * periods_per_year,)
    tr_price_history: np.ndarray    # view into _full_tr[:n_hist]
    price: np.ndarray               # (n_periods + 1,)
    tr_price: np.ndarray            # view into _full_tr[n_hist:]
    earnings: np.ndarray
    shares_outstanding: np.ndarray
    real_rate: np.ndarray
    real_rate_shadow: np.ndarray
    extrap_ret: np.ndarray
    _full_tr: np.ndarray = field(default=None, repr=False)


@dataclass
class InvestorState:
    wealth: np.ndarray   # (n_periods + 1,)
    shares: np.ndarray   # (n_periods + 1,)


@dataclass
class RandomShocks:
    earnings: np.ndarray
    real_rate: np.ndarray
    cashflow_flow: np.ndarray
    static_flow: np.ndarray
    extrap_flow: np.ndarray


def generate_random_numbers(params, seed=None):
    """Generate random normally distributed variables for simulation."""
    if seed is not None:
        np.random.seed(seed)

    n_rows = params.n_periods + 1
    random_data = np.random.randn(n_rows, 5)

    corr = params.real_rate.earnings_corr
    earnings = random_data[:, 0]
    real_rate = corr * earnings + np.sqrt(1 - corr**2) * random_data[:, 1]

    return RandomShocks(
        earnings=earnings,
        real_rate=real_rate,
        cashflow_flow=random_data[:, 2],
        static_flow=random_data[:, 3],
        extrap_flow=random_data[:, 4],
    )


def initialize(params: SimulationParams) -> tuple[MarketState, dict[str, InvestorState]]:
    """Build initial market state and investor allocations."""
    ppy = params.periods_per_year
    n = params.n_periods + 1

    # Vectorized 5-year price history (geometric growth from retained earnings)
    init_periodic_ret = (1 + params.init_exp_ret) ** (1.0 / ppy) - 1
    reinvest_rate = 1 - params.payout_ratio
    growth = 1 + init_periodic_ret * reinvest_rate
    n_hist = 5 * ppy
    steps = np.arange(n_hist)
    price_history = growth ** steps

    # Unified TR backing array: tr_price_history and tr_price are views into
    # one contiguous block, so extrap_expected_return can slice _full_tr[:n_hist + t]
    # instead of calling np.concatenate (O(1) view vs O(n) copy each step).
    total_len = n_hist + n
    _full_tr = np.zeros(total_len)
    _full_tr[:n_hist] = (1 + init_periodic_ret) ** steps

    # Initial price is one step beyond the history
    price_0 = growth ** n_hist
    tr_price_0 = (1 + init_periodic_ret) ** n_hist

    # Initial earnings from earnings yield (may differ from expected return)
    init_periodic_ey = (1 + params.init_earnings_yield) ** (1.0 / ppy) - 1

    # Pre-allocate market state (tr_price_history and tr_price are views into _full_tr)
    market = MarketState(
        price_history=price_history,
        tr_price_history=_full_tr[:n_hist],
        price=np.zeros(n),
        tr_price=_full_tr[n_hist:],
        earnings=np.zeros(n),
        shares_outstanding=np.zeros(n),
        real_rate=np.zeros(n),
        real_rate_shadow=np.zeros(n),
        extrap_ret=np.zeros(n),
        _full_tr=_full_tr,
    )
    market.price[0] = price_0
    market.tr_price[0] = tr_price_0
    market.earnings[0] = price_0 * init_periodic_ey
    market.shares_outstanding[0] = 1.0
    market.real_rate[0] = params.real_rate.init
    market.real_rate_shadow[0] = params.real_rate.init - params.real_rate.min_rate

    # Initial extrap expected return (squeezed)
    rp_raw = params.init_exp_ret - params.real_rate.init
    dev = rp_raw - params.extrap.center
    squeezed = params.extrap.max_dev * np.tanh(dev / params.extrap.squeeze)
    init_extrap_ret = params.extrap.center + squeezed + params.real_rate.init
    market.extrap_ret[0] = init_extrap_ret

    # Merton shares for cashflow and extrap investors
    vol_sq = params.vol_sq
    merton_cashflow = (params.init_earnings_yield - params.real_rate.init) / (params.crra * vol_sq)
    merton_extrap = (init_extrap_ret - params.real_rate.init) / (params.crra * vol_sq)

    # Per-investor: (population fraction, stock allocation at t=0)
    fracs = params.fractions
    investor_config = {
        "static":   (fracs.static_frac,   params.static.baseline),
        "cashflow": (fracs.cashflow_frac,  merton_cashflow),
        "extrap":   (fracs.extrap_frac,    merton_extrap),
        "stmr":     (fracs.stmr_frac,      params.stmr.baseline),
        "momentum": (fracs.mmntm_frac,     params.momentum.baseline),
        "valmo":    (fracs.valmo_frac,      params.valmo.baseline),
    }

    # Total wealth such that sum(frac * alloc) * total_wealth = price_0
    weighted_alloc = sum(frac * alloc for frac, alloc in investor_config.values())
    total_wealth = price_0 / weighted_alloc

    investors = {}
    for name, (frac, alloc) in investor_config.items():
        wealth = np.zeros(n)
        shares = np.zeros(n)
        wealth[0] = frac * total_wealth
        shares[0] = alloc * wealth[0] / price_0
        investors[name] = InvestorState(wealth=wealth, shares=shares)

    # Anticip investor (exogenous observer, not part of clearing)
    if params.include_anticip:
        wealth = np.zeros(n)
        shares = np.zeros(n)
        wealth[0] = params.anticip.initial_wealth
        shares[0] = merton_cashflow * wealth[0] / price_0
        investors["anticip"] = InvestorState(wealth=wealth, shares=shares)

    return market, investors

"""## Simulation Step

Core per-period logic. Each time step updates earnings and the real rate, computes
pre-trade wealth (dividends + interest + flows), then runs a vectorized grid search
to find the market-clearing price where total investor demand
equals share supply. The anticip investor observes the clearing outcome and forecasts
one period ahead.

**Functions:**
- `bond_return(rate_prev, rate_curr, maturity)` -- zero-coupon bond return
- `update_earnings(...)` -- next-period earnings from retained earnings + shock
- `update_real_rate(...)` -- mean-reverting shadow rate process
- `pre_trade_wealth(t, ...)` -- wealth after dividends, interest, and cash flows
- `extrap_expected_return(t, trial_tr_prices, ...)` -- weighted lookback return with squeeze
- `new_shares_outstanding(trial_prices, t, ...)` -- issuance/buyback at each trial price
- `investor_demands(trial_prices, ...)` -- per-investor share demand vectors
- `find_clearing_price(t, ...)` -- grid search + linear interpolation for equilibrium
- `anticip_forecast_extrap_return(t, ...)` -- extrap return for anticip scenarios
- `anticip_forecast_clearing_price(t, ...)` -- clearing price across 32 scenarios
- `anticip_forecast_next_price(t, ...)` -- mean and std of forecasted next price
- `step(t, ...)` -- advance the full simulation by one period
"""

# @title
# Simulation step and helpers.

CORE_INVESTORS = ("static", "cashflow", "extrap", "stmr", "momentum", "valmo")

# Which investors receive random cash flows (the rest have no flows).
FLOW_SHOCKS = {
    "static": lambda s: s.static_flow,
    "cashflow": lambda s: s.cashflow_flow,
    "extrap": lambda s: s.extrap_flow,
}

# Pre-computed 32 scenario shock patterns: (32, 5) with values +1 or -1.
# Columns: earnings, real_rate, cashflow_flow, static_flow, extrap_flow.
ANTICIP_SCENARIOS = np.array([
    [(1 if (s >> j) & 1 else -1) for j in range(5)]
    for s in range(32)
], dtype=float)


@dataclass
class ClearingResult:
    """Result of market clearing: price, derived quantities, and per-investor demands."""
    price: float
    tr_price: float
    extrap_ret: float
    shares_outstanding: float
    demands: dict[str, float]
    total_demand: float


def bond_return(rate_prev: float, rate_curr: float, maturity: float) -> float:
    """Per-period return on a zero-coupon bond with given maturity."""
    if maturity == 0.0:
        return 0.0
    if rate_curr == 0.0:
        return rate_prev * maturity
    return (
        rate_prev * (1 - (1 + rate_curr) ** -maturity) / rate_curr
        + (1 + rate_curr) ** -maturity
    ) - 1


def update_earnings(
    prev_earnings: float,
    prev_price: float,
    prev_rate: float,
    earnings_shock: float,
    params: SimulationParams,
) -> float:
    """Compute new earnings from previous state and a shock value."""
    ppy = params.periods_per_year
    reinvest_rate = 1 - params.payout_ratio
    retained = prev_earnings * reinvest_rate
    max_eg = (1 + prev_rate + params.max_excess_earnings_growth) ** (1.0 / ppy) - 1
    earnings_growth = min(retained / prev_price, max_eg * reinvest_rate)
    shock = earnings_shock * params.earnings_vol / np.sqrt(ppy)
    return prev_earnings * (1 + earnings_growth) * (1 + shock)


def update_real_rate(
    prev_shadow: float,
    prev_rate: float,
    rate_shock: float,
    params: SimulationParams,
) -> tuple[float, float]:
    """Compute new (shadow, real_rate) from previous state and a shock value."""
    ppy = params.periods_per_year
    rr = params.real_rate
    mr_term = rr.mr_speed * (rr.target - prev_rate) / ppy
    shock = rate_shock * rr.vol / np.sqrt(ppy)
    shadow = prev_shadow * (1 + shock) + mr_term
    return shadow, shadow + rr.min_rate


def pre_trade_wealth(
    t: int,
    params: SimulationParams,
    market: MarketState,
    investors: dict[str, InvestorState],
    shocks: RandomShocks,
) -> dict[str, float]:
    """Compute pre-trade wealth for each core investor at time t."""
    ppy = params.periods_per_year
    periodic_rate = (1 + market.real_rate[t - 1]) ** (1.0 / ppy) - 1
    div_per_share = market.earnings[t - 1] * params.payout_ratio
    bond_ret = bond_return(
        market.real_rate[t - 1], market.real_rate[t], params.real_rate.bond_maturity
    )
    flow_scale = params.inout_vol / np.sqrt(ppy)

    ptw = {}
    for name in CORE_INVESTORS:
        inv = investors[name]
        w_prev = inv.wealth[t - 1]
        s_prev = inv.shares[t - 1]
        stock_val = s_prev * market.price[t - 1]
        cash = w_prev - stock_val
        divs = s_prev * div_per_share
        interest = cash * periodic_rate

        flow_fn = FLOW_SHOCKS.get(name)
        flow = flow_fn(shocks)[t] * flow_scale * w_prev if flow_fn else 0.0

        ptw[name] = w_prev + divs + interest + flow + cash * bond_ret

    return ptw


def extrap_expected_return(
    t: int,
    trial_tr_prices: np.ndarray,
    params: SimulationParams,
    market: MarketState,
) -> np.ndarray:
    """Vectorized extrap expected return over an array of trial TR prices.

    Years 2-5 of the weighted lookback are precomputed once (they don't depend
    on the trial price). Only year 1 varies, giving full vectorization.
    """
    ppy = params.periods_per_year
    ep = params.extrap
    weights = ep.weights

    # Use unified backing array (O(1) view instead of O(n) np.concatenate)
    n_hist = len(market.tr_price_history)
    all_tr = market._full_tr[:n_hist + t]
    # The trial price sits at virtual index len(all_tr) (one past the end).
    # Lookbacks are relative to that position so each year spans exactly ppy periods.
    virtual_idx = len(all_tr)

    # Precompute the year-1 reference price and years 2-5 contribution
    first_year_past = all_tr[virtual_idx - ppy]
    rest_return = 0.0
    curr_idx = virtual_idx
    for i, w in enumerate(weights):
        past_idx = curr_idx - ppy
        if i > 0:
            rest_return += w * np.log(all_tr[curr_idx] / all_tr[past_idx])
        curr_idx = past_idx

    # Vectorized: only the log(trial / past_1yr) term varies across trial prices
    avg_ret = weights[0] * np.log(trial_tr_prices / first_year_past) + rest_return

    rp_raw = avg_ret - market.real_rate[t]
    dev = rp_raw - ep.center
    squeezed = ep.max_dev * np.tanh(dev / ep.squeeze)
    current_ret = ep.center + squeezed + market.real_rate[t]

    pct = ep.pct_current(ppy)
    return pct * current_ret + (1 - pct) * market.extrap_ret[t - 1]


def new_shares_outstanding(
    trial_prices: np.ndarray,
    t: int,
    params: SimulationParams,
    market: MarketState,
) -> np.ndarray:
    """Vectorized shares outstanding at each trial price."""
    ppy = params.periods_per_year
    iss = params.issuance
    prev_shares = market.shares_outstanding[t - 1]

    ey = (1 + market.earnings[t] / trial_prices) ** ppy - 1
    rp = ey - market.real_rate[t]

    periodic_iss = (1 + iss.issuance_rate) ** (1.0 / ppy) - 1
    periodic_buy = (1 + iss.buyback_rate) ** (1.0 / ppy) - 1

    return np.where(
        rp < iss.issuance_threshold,
        prev_shares * (1 + periodic_iss),
        np.where(rp > iss.buyback_threshold, prev_shares * (1 - periodic_buy), prev_shares),
    )


def investor_demands(
    trial_prices: np.ndarray,
    trial_tr_prices: np.ndarray,
    t: int,
    params: SimulationParams,
    market: MarketState,
    investors: dict[str, InvestorState],
    ptw: dict[str, float],
) -> dict[str, np.ndarray]:
    """Per-investor share demands, vectorized over trial prices.

    Returns a dict mapping investor name -> demand array (one element per trial price).
    """
    ppy = params.periods_per_year
    vol_sq = params.vol_sq
    delta = trial_prices - market.price[t - 1]

    def adj_w(name: str) -> np.ndarray:
        return ptw[name] + investors[name].shares[t - 1] * delta

    demands = {}

    # Static: constant allocation
    demands["static"] = params.static.baseline * adj_w("static") / trial_prices

    # Cashflow: Merton share from earnings yield
    ey = (1 + market.earnings[t] / trial_prices) ** ppy - 1
    rp = ey - market.real_rate[t]
    alloc = np.clip(rp / (params.crra * vol_sq), params.short_max, params.lev_max)
    demands["cashflow"] = alloc * adj_w("cashflow") / trial_prices

    # Extrap: Merton share from extrapolated return
    extrap_ret = extrap_expected_return(t, trial_tr_prices, params, market)
    rp_ext = extrap_ret - market.real_rate[t]
    alloc = np.clip(rp_ext / (params.crra * vol_sq), params.short_max, params.lev_max)
    demands["extrap"] = alloc * adj_w("extrap") / trial_prices

    # STMR: short-term mean reversion (variance-adjusted deviation)
    stmr_lb = params.stmr.lookback_periods(ppy)
    if t >= stmr_lb:
        lookback_tr = market.tr_price[t - stmr_lb]

        # Period return over lookback (not annualized)
        return_period = trial_tr_prices / lookback_tr - 1

        # Expected return over the same lookback period
        expected_return_period = (1 + params.init_earnings_yield) ** (stmr_lb / ppy) - 1

        # Excess return and its variance
        excess_return = return_period - expected_return_period
        variance = excess_return ** 2

        # Deviation is min of fixed deviation or variance-scaled deviation
        max_dev_v = params.stmr.max_dev_var(params.stock_vol_assumed)
        deviation_used = np.minimum(
            params.stmr.deviation,
            params.stmr.deviation * variance / max_dev_v,
        )

        # Negative excess return → higher allocation; positive → lower
        stmr_alloc = np.where(
            excess_return < 0,
            params.stmr.baseline + deviation_used,
            params.stmr.baseline - deviation_used,
        )
        demands["stmr"] = stmr_alloc * adj_w("stmr") / trial_prices
    else:
        demands["stmr"] = np.full_like(trial_prices, investors["stmr"].shares[t - 1])

    # Momentum
    mmntm_lb = params.momentum.lookback_periods(ppy)
    if t >= mmntm_lb:
        lookback_tr = market.tr_price[t - mmntm_lb]
        ret_pa = (trial_tr_prices / lookback_tr) ** (ppy / mmntm_lb) - 1
        mmntm_alloc = np.where(
            ret_pa > params.init_earnings_yield,
            params.momentum.baseline + params.momentum.deviation,
            params.momentum.baseline - params.momentum.deviation,
        )
        demands["momentum"] = mmntm_alloc * adj_w("momentum") / trial_prices
    else:
        demands["momentum"] = np.full_like(trial_prices, investors["momentum"].shares[t - 1])

    # Valmo: value + momentum hybrid
    valmo_lb = params.valmo.lookback_periods(ppy)
    if t >= valmo_lb:
        lookback_tr = market.tr_price[t - valmo_lb]
        tr_change = trial_tr_prices - lookback_tr
        momentum_frac = np.where(
            tr_change > 0,
            params.valmo.momentum_weight * params.valmo.baseline,
            -params.valmo.momentum_weight * params.valmo.baseline,
        )
        # Value component (reuses ey from cashflow)
        rp_val = ey - market.real_rate[t]
        opt = np.clip(
            rp_val / (params.crra * vol_sq),
            (1 - params.valmo.rp_max) * params.valmo.baseline,
            (1 + params.valmo.rp_max) * params.valmo.baseline,
        )
        opt = np.clip(opt + momentum_frac, params.short_max, params.lev_max)
        demands["valmo"] = opt * adj_w("valmo") / trial_prices
    else:
        demands["valmo"] = np.full_like(trial_prices, investors["valmo"].shares[t - 1])

    return demands


def find_clearing_price(
    t: int,
    params: SimulationParams,
    market: MarketState,
    investors: dict[str, InvestorState],
    ptw: dict[str, float],
    grid: GridParams,
    pcts: np.ndarray,
) -> ClearingResult:
    """Vectorized grid search for market clearing price.

    Returns a ClearingResult with the clearing price, TR price, extrap return,
    shares outstanding, and interpolated per-investor demands -- eliminating the
    need for separate re-evaluation calls in step().
    """
    prev_price = market.price[t - 1]
    prev_tr_price = market.tr_price[t - 1]
    div_per_share = market.earnings[t - 1] * params.payout_ratio

    trial_prices = prev_price * (1 + pcts)
    trial_tr_prices = prev_tr_price * (trial_prices + div_per_share) / prev_price

    demands = investor_demands(
        trial_prices, trial_tr_prices, t, params, market, investors, ptw
    )
    total_demand = sum(demands.values())
    supply = new_shares_outstanding(trial_prices, t, params, market)
    imbalance = total_demand - supply

    # Find sign changes (demand crosses supply)
    signs = np.sign(imbalance)
    sign_change_mask = signs[:-1] * signs[1:] < 0
    sign_changes = np.where(sign_change_mask)[0]

    if len(sign_changes) > 0:
        # Pick the sign change closest to zero price move
        best_idx = sign_changes[np.argmin(np.abs(pcts[sign_changes]))]
        pct1, pct2 = pcts[best_idx], pcts[best_idx + 1]
        imb1, imb2 = imbalance[best_idx], imbalance[best_idx + 1]
        pct_interp = pct1 - imb1 * (pct2 - pct1) / (imb2 - imb1)
        pct_interp = float(np.clip(pct_interp, -grid.max_price_move, grid.max_price_move))
    else:
        best_idx = int(np.argmin(np.abs(imbalance)))
        pct_interp = float(np.clip(pcts[best_idx], -grid.max_price_move, grid.max_price_move))

    clearing_price = prev_price * (1 + pct_interp)
    clearing_tr = prev_tr_price * (clearing_price + div_per_share) / prev_price

    # Re-evaluate at the exact clearing price for precise share allocation
    cp = np.array([clearing_price])
    ctr = np.array([clearing_tr])
    clearing_demands = investor_demands(cp, ctr, t, params, market, investors, ptw)
    clearing_supply = float(new_shares_outstanding(cp, t, params, market)[0])
    clearing_extrap_ret = float(extrap_expected_return(t, ctr, params, market)[0])
    clearing_total = float(sum(d[0] for d in clearing_demands.values()))

    return ClearingResult(
        price=clearing_price,
        tr_price=clearing_tr,
        extrap_ret=clearing_extrap_ret,
        shares_outstanding=clearing_supply,
        demands={name: float(d[0]) for name, d in clearing_demands.items()},
        total_demand=clearing_total,
    )


# --- Anticip investor helpers (vectorized across 32 scenarios × grid points) ---

def anticip_forecast_extrap_return(
    t: int,
    trial_tr_prices: np.ndarray,
    next_real_rate: np.ndarray,
    params: SimulationParams,
    market: MarketState,
) -> np.ndarray:
    """Extrap expected return for anticip forecasts.

    trial_tr_prices: (32, n_grid) or (n_grid,)
    next_real_rate: (32,) or scalar
    Returns same shape as trial_tr_prices.
    """
    ppy = params.periods_per_year
    ep = params.extrap
    weights = ep.weights

    # Use unified backing array (O(1) view instead of O(n) np.concatenate)
    n_hist = len(market.tr_price_history)
    all_tr = market._full_tr[:n_hist + t + 1]
    virtual_idx = len(all_tr)

    # Year-1 reference and years 2-5 contribution (same as extrap_expected_return)
    first_year_past = all_tr[virtual_idx - ppy]
    rest_return = 0.0
    curr_idx = virtual_idx
    for i, w in enumerate(weights):
        past_idx = curr_idx - ppy
        if i > 0:
            rest_return += w * np.log(all_tr[curr_idx] / all_tr[past_idx])
        curr_idx = past_idx

    # Broadcast: trial_tr_prices may be (32, n_grid), next_real_rate (32, 1)
    if next_real_rate.ndim == 1:
        nr = next_real_rate[:, np.newaxis]  # (32, 1)
    else:
        nr = next_real_rate

    avg_ret = weights[0] * np.log(trial_tr_prices / first_year_past) + rest_return

    rp_raw = avg_ret - nr
    dev = rp_raw - ep.center
    squeezed = ep.max_dev * np.tanh(dev / ep.squeeze)
    current_ret = ep.center + squeezed + nr

    pct = ep.pct_current(ppy)
    # Anticip blends with extrap_ret[t] (not t-1), since t is already computed
    return pct * current_ret + (1 - pct) * market.extrap_ret[t]


def anticip_forecast_clearing_price(
    t: int,
    params: SimulationParams,
    market: MarketState,
    investors: dict[str, InvestorState],
    current_price: float,
    current_tr_price: float,
    next_earnings: np.ndarray,
    next_real_rate: np.ndarray,
    next_wealths: dict[str, np.ndarray],
    grid: GridParams,
    anticip_pcts: np.ndarray,
) -> np.ndarray:
    """Find clearing price for each of 32 forecast scenarios.

    All array inputs are (32,). Returns (32,) forecast prices.
    """
    ppy = params.periods_per_year
    vol_sq = params.vol_sq
    n_scenarios = len(next_earnings)

    pcts = anticip_pcts
    n_grid = len(pcts)

    trial_prices = current_price * (1 + pcts)                            # (n_grid,)
    next_div = next_earnings[:, np.newaxis] * params.payout_ratio        # (32, 1)
    trial_tr_prices = current_tr_price * (trial_prices + next_div) / current_price  # (32, n_grid)

    # Delta from current_price (prev for forecast step is current_price)
    delta = trial_prices - current_price  # (n_grid,)

    # --- Per-investor demands: (32, n_grid) ---
    # Helper: adjusted wealth per scenario and grid point
    def adj_w(name: str) -> np.ndarray:
        return next_wealths[name][:, np.newaxis] + investors[name].shares[t] * delta  # (32, n_grid)

    nr = next_real_rate[:, np.newaxis]  # (32, 1) for broadcasting

    total_demand = np.zeros((n_scenarios, n_grid))

    # Static
    total_demand += params.static.baseline * adj_w("static") / trial_prices

    # Cashflow: Merton from forecast earnings yield
    ey = (1 + next_earnings[:, np.newaxis] / trial_prices) ** ppy - 1  # (32, n_grid)
    rp = ey - nr
    alloc = np.clip(rp / (params.crra * vol_sq), params.short_max, params.lev_max)
    total_demand += alloc * adj_w("cashflow") / trial_prices

    # Extrap: Merton from forecast extrap return
    extrap_ret = anticip_forecast_extrap_return(t, trial_tr_prices, next_real_rate, params, market)
    rp_ext = extrap_ret - nr
    alloc = np.clip(rp_ext / (params.crra * vol_sq), params.short_max, params.lev_max)
    total_demand += alloc * adj_w("extrap") / trial_prices

    # STMR: lookback uses t+1 as the forecast index (variance-adjusted deviation)
    stmr_lb = params.stmr.lookback_periods(ppy)
    if t + 1 >= stmr_lb:
        lookback_tr = market.tr_price[(t + 1) - stmr_lb]

        # Period return over lookback (not annualized)
        return_period = trial_tr_prices / lookback_tr - 1

        # Expected return over the same lookback period
        expected_return_period = (1 + params.init_earnings_yield) ** (stmr_lb / ppy) - 1

        # Excess return and its variance
        excess_return = return_period - expected_return_period
        variance = excess_return ** 2

        # Deviation is min of fixed deviation or variance-scaled deviation
        max_dev_v = params.stmr.max_dev_var(params.stock_vol_assumed)
        deviation_used = np.minimum(
            params.stmr.deviation,
            params.stmr.deviation * variance / max_dev_v,
        )

        # Negative excess return → higher allocation; positive → lower
        stmr_alloc = np.where(
            excess_return < 0,
            params.stmr.baseline + deviation_used,
            params.stmr.baseline - deviation_used,
        )
        total_demand += stmr_alloc * adj_w("stmr") / trial_prices
    else:
        total_demand += investors["stmr"].shares[t]

    # Momentum
    mmntm_lb = params.momentum.lookback_periods(ppy)
    if t + 1 >= mmntm_lb:
        lookback_tr = market.tr_price[(t + 1) - mmntm_lb]
        ret_pa = (trial_tr_prices / lookback_tr) ** (ppy / mmntm_lb) - 1
        mmntm_alloc = np.where(
            ret_pa > params.init_earnings_yield,
            params.momentum.baseline + params.momentum.deviation,
            params.momentum.baseline - params.momentum.deviation,
        )
        total_demand += mmntm_alloc * adj_w("momentum") / trial_prices
    else:
        total_demand += investors["momentum"].shares[t]

    # Valmo
    valmo_lb = params.valmo.lookback_periods(ppy)
    if t + 1 >= valmo_lb:
        lookback_tr = market.tr_price[(t + 1) - valmo_lb]
        tr_change = trial_tr_prices - lookback_tr
        momentum_frac = np.where(
            tr_change > 0,
            params.valmo.momentum_weight * params.valmo.baseline,
            -params.valmo.momentum_weight * params.valmo.baseline,
        )
        rp_val = ey - nr
        opt = np.clip(
            rp_val / (params.crra * vol_sq),
            (1 - params.valmo.rp_max) * params.valmo.baseline,
            (1 + params.valmo.rp_max) * params.valmo.baseline,
        )
        opt = np.clip(opt + momentum_frac, params.short_max, params.lev_max)
        total_demand += opt * adj_w("valmo") / trial_prices
    else:
        total_demand += investors["valmo"].shares[t]

    # --- Supply: (32, n_grid) ---
    iss = params.issuance
    prev_shares = market.shares_outstanding[t]
    ey_supply = (1 + next_earnings[:, np.newaxis] / trial_prices) ** ppy - 1
    rp_supply = ey_supply - nr
    periodic_iss = (1 + iss.issuance_rate) ** (1.0 / ppy) - 1
    periodic_buy = (1 + iss.buyback_rate) ** (1.0 / ppy) - 1
    supply = np.where(
        rp_supply < iss.issuance_threshold,
        prev_shares * (1 + periodic_iss),
        np.where(rp_supply > iss.buyback_threshold, prev_shares * (1 - periodic_buy), prev_shares),
    )

    # --- Find clearing price per scenario ---
    imbalance = total_demand - supply  # (32, n_grid)

    forecast_prices = np.empty(n_scenarios)
    for s in range(n_scenarios):
        imb = imbalance[s]
        signs = np.sign(imb)
        sign_change_mask = signs[:-1] * signs[1:] < 0
        sign_changes = np.where(sign_change_mask)[0]

        if len(sign_changes) > 0:
            best_idx = sign_changes[np.argmin(np.abs(pcts[sign_changes]))]
            pct1, pct2 = pcts[best_idx], pcts[best_idx + 1]
            imb1, imb2 = imb[best_idx], imb[best_idx + 1]
            pct_interp = pct1 - imb1 * (pct2 - pct1) / (imb2 - imb1)
            pct_interp = np.clip(pct_interp, -grid.max_price_move, grid.max_price_move)
        else:
            best_idx = np.argmin(np.abs(imb))
            pct_interp = np.clip(pcts[best_idx], -grid.max_price_move, grid.max_price_move)

        forecast_prices[s] = current_price * (1 + pct_interp)

    return forecast_prices


def anticip_forecast_next_price(
    t: int,
    params: SimulationParams,
    market: MarketState,
    investors: dict[str, InvestorState],
    current_price: float,
    current_tr_price: float,
    grid: GridParams,
    anticip_pcts: np.ndarray,
) -> tuple[float, float]:
    """Forecast next-period clearing price using 32 scenarios.

    Returns (mean_price, std_price).
    """
    ppy = params.periods_per_year
    rr = params.real_rate
    corr = rr.earnings_corr

    scenarios = ANTICIP_SCENARIOS

    shock_earn = scenarios[:, 0]   # (32,)
    shock_rr   = scenarios[:, 1]   # (32,)
    shock_cf   = scenarios[:, 2]   # (32,)
    shock_st   = scenarios[:, 3]   # (32,)
    shock_ex   = scenarios[:, 4]   # (32,)

    # --- Project next-period earnings (simplified: no max_excess cap, matching v6) ---
    reinvest_rate = 1 - params.payout_ratio
    retained = market.earnings[t] * reinvest_rate
    earnings_growth = retained / market.price[t]
    earnings_shock = shock_earn * params.earnings_vol / np.sqrt(ppy)
    next_earnings = market.earnings[t] * (1 + earnings_growth) * (1 + earnings_shock)  # (32,)

    # --- Project next-period real rate ---
    realrate_shock_corr = corr * shock_earn + np.sqrt(1 - corr**2) * shock_rr
    rate_shock = realrate_shock_corr * rr.vol / np.sqrt(ppy)
    mr_term = rr.mr_speed * (rr.target - market.real_rate[t]) / ppy
    next_shadow = market.real_rate_shadow[t] * (1 + rate_shock) + mr_term  # (32,)
    next_real_rate = next_shadow + rr.min_rate                              # (32,)

    # --- Project next-period pre-trade wealths ---
    next_periodic_rate = (1 + market.real_rate[t]) ** (1.0 / ppy) - 1
    next_div = next_earnings * params.payout_ratio  # (32,) dividend per share
    flow_scale = params.inout_vol / np.sqrt(ppy)

    next_wealths = {}
    for name in CORE_INVESTORS:
        inv = investors[name]
        w_t = inv.wealth[t]
        s_t = inv.shares[t]
        stock_val = s_t * current_price
        cash = w_t - stock_val
        divs = s_t * next_div         # (32,)
        interest = cash * next_periodic_rate

        # Cash flows: static uses shock_st, cashflow uses shock_cf, extrap uses shock_ex
        if name == "static":
            flow = shock_st * flow_scale * w_t
        elif name == "cashflow":
            flow = shock_cf * flow_scale * w_t
        elif name == "extrap":
            flow = shock_ex * flow_scale * w_t
        else:
            flow = 0.0

        next_wealths[name] = w_t + divs + interest + flow  # (32,)

    # --- Find clearing prices for all 32 scenarios ---
    forecast_prices = anticip_forecast_clearing_price(
        t, params, market, investors,
        current_price, current_tr_price,
        next_earnings, next_real_rate, next_wealths,
        grid, anticip_pcts,
    )

    return float(np.mean(forecast_prices)), float(np.std(forecast_prices))


def step(
    t: int,
    params: SimulationParams,
    market: MarketState,
    investors: dict[str, InvestorState],
    shocks: RandomShocks,
    grid: GridParams,
    pcts: np.ndarray,
    anticip_pcts: np.ndarray | None = None,
):
    """Advance simulation by one time step. Mutates market and investors in place."""
    ppy = params.periods_per_year

    # --- Update earnings and real rate ---
    market.earnings[t] = update_earnings(
        market.earnings[t - 1],
        market.price[t - 1],
        market.real_rate[t - 1],
        shocks.earnings[t],
        params,
    )
    shadow, rate = update_real_rate(
        market.real_rate_shadow[t - 1],
        market.real_rate[t - 1],
        shocks.real_rate[t],
        params,
    )
    market.real_rate_shadow[t] = shadow
    market.real_rate[t] = rate

    # --- Pre-trade wealth ---
    ptw = pre_trade_wealth(t, params, market, investors, shocks)

    # --- Find clearing price (returns all derived quantities) ---
    result = find_clearing_price(t, params, market, investors, ptw, grid, pcts)
    market.price[t] = result.price
    market.tr_price[t] = result.tr_price
    market.extrap_ret[t] = result.extrap_ret
    market.shares_outstanding[t] = result.shares_outstanding

    # --- Allocate shares and update wealth ---
    delta_price = result.price - market.price[t - 1]
    scale = result.shares_outstanding / result.total_demand

    for name in CORE_INVESTORS:
        inv = investors[name]
        inv.shares[t] = result.demands[name] * scale
        inv.wealth[t] = ptw[name] + inv.shares[t - 1] * delta_price

    # --- Anticip investor (exogenous observer, trades after clearing) ---
    if params.include_anticip and "anticip" in investors:
        anticip_inv = investors["anticip"]
        periodic_rate = (1 + market.real_rate[t - 1]) ** (1.0 / ppy) - 1

        # Pre-trade wealth (dividends + interest, no flows)
        div_per_share = market.earnings[t - 1] * params.payout_ratio
        stock_val = anticip_inv.shares[t - 1] * market.price[t - 1]
        cash = anticip_inv.wealth[t - 1] - stock_val
        divs = anticip_inv.shares[t - 1] * div_per_share
        interest = cash * periodic_rate
        wealth_before = anticip_inv.wealth[t - 1] + divs + interest

        # Account for price change
        wealth_after = wealth_before + anticip_inv.shares[t - 1] * delta_price

        # Forecast next-period price
        forecast_mean, forecast_std = anticip_forecast_next_price(
            t, params, market, investors, result.price, result.tr_price,
            grid, anticip_pcts,
        )

        # Merton-style allocation from forecast
        expected_return = (forecast_mean - result.price) / result.price
        risk = max(0.001, forecast_std) / result.price
        target_pct = max(
            params.short_max,
            min(
                params.lev_max,
                (expected_return - periodic_rate) / (risk**2) / params.anticip.risk_aversion,
            ),
        )

        anticip_inv.shares[t] = target_pct * wealth_after / result.price
        anticip_inv.wealth[t] = wealth_after

"""## Simulation Runner

Top-level functions that wire everything together. `run_simulation` executes a single
simulation from seed to completion. `run_monte_carlo` runs multiple simulations with
sequential seeds and averages the resulting statistics, handling volatilities and
Sharpe ratios.

**Functions:**
- `run_simulation(params, seed)` -- generate shocks, initialize, loop through all periods
- `average_statistics(all_stats, ppy)` -- correctly average vols and Sharpes across runs
- `run_monte_carlo(params, n_sims, base_seed)` -- run N simulations and return averaged stats
"""

# @title
import time


def run_simulation(
    params: SimulationParams,
    seed: int | None = None,
) -> tuple[MarketState, dict[str, InvestorState], RandomShocks]:
    """Run full simulation: generate shocks, initialize, step through all periods."""
    shocks = generate_random_numbers(params, seed=seed)
    market, investors = initialize(params)

    # Pre-compute grid and trial-price arrays once for the entire simulation
    grid = params.resolved_grid()
    pcts = np.arange(
        -grid.max_grid_move, grid.max_grid_move + grid.step_size / 2, grid.step_size
    )
    anticip_pcts = (
        np.arange(-grid.max_grid_move, grid.max_grid_move + 0.01, grid.anticip_step_size)
        if params.include_anticip else None
    )

    for t in range(1, params.n_periods + 1):
        step(t, params, market, investors, shocks, grid, pcts, anticip_pcts)
    return market, investors, shocks


def average_statistics(
    all_stats: list[dict[str, float]],
    ppy: int,
) -> dict[str, float]:
    """Average statistics across multiple simulations.

    Volatilities are averaged as sqrt(mean(variance)).
    Sharpe ratios are recomputed from averaged excess returns and variances.
    Everything else is a simple mean.
    """
    if not all_stats:
        return {}

    keys = all_stats[0].keys()
    ns = len(all_stats)
    avg = {}

    # Identify vol keys that should be averaged via variance
    vol_keys = {k for k in keys if k.endswith("_vol") and k != "vol_of_vol"}

    # Identify sharpe keys that should be recomputed
    sharpe_keys = {k for k in keys if k.endswith("_sharpe")}

    # Simple mean for everything first
    for key in keys:
        values = [s[key] for s in all_stats]
        avg[key] = float(np.mean(values))
        avg[f"{key}_se"] = float(np.std(values) / np.sqrt(ns))

    # Override vols: average variance then sqrt
    for key in vol_keys:
        variances = [s[key] ** 2 for s in all_stats]
        avg[key] = float(np.sqrt(np.mean(variances)))

    # Override sharpes: recompute from averaged excess return / sqrt(avg variance)
    for key in sharpe_keys:
        prefix = key.removesuffix("_sharpe")
        # Check for directly stored excess return and variance first (e.g. tr_sharpe)
        excess_key = f"{prefix}_excess_return"
        var_key = f"{prefix}_variance"
        if excess_key in keys and var_key in keys:
            avg_excess = float(np.mean([s[excess_key] for s in all_stats]))
            avg_var = float(np.mean([s[var_key] for s in all_stats]))
            if avg_var > 0:
                avg[key] = avg_excess / np.sqrt(avg_var) * np.sqrt(ppy)
            else:
                avg[key] = 0.0
            continue
        # Fall back to recovering from per-sim sharpe and vol
        vol_key = f"{prefix}_vol"
        if vol_key not in keys:
            continue
        # Recover periodic excess return: sharpe_i * vol_i / sqrt(ppy)
        excess_rets = []
        variances = []
        for s in all_stats:
            vol_periodic = s[vol_key] / np.sqrt(ppy)
            excess_rets.append(s[key] * vol_periodic)  # sharpe * vol_periodic = excess_ret_periodic
            variances.append(vol_periodic ** 2)
        avg_excess = float(np.mean(excess_rets))
        avg_var = float(np.mean(variances))
        if avg_var > 0:
            avg[key] = avg_excess / np.sqrt(avg_var)
        else:
            avg[key] = 0.0

    return avg


def run_monte_carlo(
    params: SimulationParams,
    n_sims: int = 10,
    base_seed: int = 42,
) -> tuple[dict[str, float], list[dict[str, float]], list[tuple[MarketState, dict[str, InvestorState]]]]:
    """Run multiple simulations and return averaged + individual statistics.

    Returns (avg_stats, all_stats, all_results) where all_results is a list of
    (market, investors) tuples for plotting.
    """
    all_stats = []
    all_results = []
    t0 = time.perf_counter()

    for i in range(n_sims):
        seed = base_seed + i if base_seed is not None else None
        market, investors, shocks = run_simulation(params, seed=seed)
        stats = calculate_statistics(params, market, investors, shocks)
        all_stats.append(stats)
        all_results.append((market, investors))
        elapsed = time.perf_counter() - t0
        print(f"\r  Sim {i+1}/{n_sims} done  ({elapsed:.1f}s elapsed)", end="", flush=True)

    total = time.perf_counter() - t0
    print(f"Total: {total:.1f}s  ({total/n_sims:.1f}s/sim)")

    avg_stats = average_statistics(all_stats, params.periods_per_year)
    return avg_stats, all_stats, all_results

"""## Statistics & Display

Post-simulation analysis. `calculate_statistics` computes market-level metrics
(CAGR, vol, Sharpe, drawdowns, decade vols, vol clustering) and per-investor
metrics (average equity allocation, wealth CAGR, Sharpe, final wealth share).
`display_statistics` renders everything as formatted pandas tables, optionally
including standard errors from Monte Carlo runs.

**Functions:**
- `periodic_returns(series)` -- simple period-over-period returns
- `annualized_vol(returns, ppy)` -- standard deviation scaled to annual
- `cagr(series, years)` -- compound annual growth rate
- `max_drawdown(series)` -- worst peak-to-trough decline
- `sharpe_ratio(returns, rf_returns, ppy)` -- annualized excess return / vol
- `rolling_vol(returns, window, ppy)` -- sliding-window annualized volatility
- `calculate_statistics(params, market, investors, shocks)` -- full stat dict
- `display_statistics(stats, investors, title, show_se)` -- pandas table output
"""

# @title
# Statistics: pure helper functions + one main function.

def periodic_returns(series: np.ndarray) -> np.ndarray:
    """Simple period-over-period returns: (s[t] / s[t-1]) - 1."""
    return series[1:] / series[:-1] - 1


def annualized_vol(returns: np.ndarray, ppy: int) -> float:
    return float(np.std(returns) * np.sqrt(ppy))


def cagr(series: np.ndarray, years: float) -> float:
    return float((series[-1] / series[0]) ** (1 / years) - 1)


def max_drawdown(series: np.ndarray) -> float:
    peak = np.maximum.accumulate(series)
    return float(np.min((series - peak) / peak))


def sharpe_ratio(returns: np.ndarray, rf_returns: np.ndarray, ppy: int) -> float:
    excess = np.mean(returns) - np.mean(rf_returns)
    vol = np.std(returns)
    return float(excess / vol * np.sqrt(ppy)) if vol > 0 else 0.0


def rolling_vol(returns: np.ndarray, window: int, ppy: int) -> np.ndarray:
    """Rolling annualized vol via sliding window."""
    n = len(returns) - window + 1
    # cumulative sum trick for variance: E[x^2] - E[x]^2
    cs = np.cumsum(returns)
    cs2 = np.cumsum(returns ** 2)
    s = cs[window:] - cs[:n - 1]
    s2 = cs2[window:] - cs2[:n - 1]
    # prepend the first window
    s = np.concatenate([[cs[window - 1]], s])
    s2 = np.concatenate([[cs2[window - 1]], s2])
    var = s2 / window - (s / window) ** 2
    return np.sqrt(np.maximum(var, 0.0)) * np.sqrt(ppy)


def calculate_statistics(
    params: SimulationParams,
    market: MarketState,
    investors: dict[str, InvestorState],
    shocks: RandomShocks,
) -> dict[str, float]:
    """Compute all summary statistics from a completed simulation."""
    ppy = params.periods_per_year
    n = params.n_periods + 1
    years = (n - 1) / ppy

    price_ret = periodic_returns(market.price)
    tr_ret = periodic_returns(market.tr_price)
    earn_ret = periodic_returns(market.earnings)
    rf_periodic = (1 + market.real_rate[1:]) ** (1.0 / ppy) - 1

    stats: dict[str, float] = {}

    # --- Market-level ---
    stats["price_vol"] = annualized_vol(price_ret, ppy)
    stats["price_cagr"] = cagr(market.price, years)
    stats["tr_cagr"] = cagr(market.tr_price, years)
    tr_excess_periodic = float(np.mean(tr_ret) - np.mean(rf_periodic))
    tr_var_periodic = float(np.std(tr_ret) ** 2)
    stats["tr_sharpe"] = (
        float(tr_excess_periodic / np.sqrt(tr_var_periodic) * np.sqrt(ppy))
        if tr_var_periodic > 0 else 0.0
    )
    stats["tr_excess_return"] = tr_excess_periodic
    stats["tr_variance"] = tr_var_periodic
    stats["earnings_vol"] = annualized_vol(earn_ret, ppy)
    stats["final_real_rate"] = float(market.real_rate[-1])

    # Earnings yields
    t10 = min(10 * ppy, n - 1)
    stats["ey_10yr"] = float((1 + market.earnings[t10] / market.price[t10]) ** ppy - 1)
    stats["ey_final"] = float((1 + market.earnings[-1] / market.price[-1]) ** ppy - 1)

    # Drawdowns
    stats["price_max_dd"] = max_drawdown(market.price)
    stats["tr_max_dd"] = max_drawdown(market.tr_price)
    stats["earnings_max_dd"] = max_drawdown(market.earnings)

    # Vol of vol and clustering (quarterly rolling window)
    window = int(0.25 * ppy)
    rvols = rolling_vol(tr_ret, window, ppy)
    stats["vol_of_vol"] = float(np.std(rvols))
    if len(rvols) > window:
        stats["vol_clustering"] = float(np.corrcoef(rvols[:-window], rvols[window:])[0, 1])
    else:
        stats["vol_clustering"] = 0.0

    # Price limit hits
    grid = params.resolved_grid()
    stats["frac_max_up"] = float(np.mean(np.abs(price_ret - grid.max_price_move) < 1e-4))
    stats["frac_max_down"] = float(np.mean(np.abs(price_ret + grid.max_price_move) < 1e-4))

    # Decade vols
    for d in range(int(years) // 10):
        start, end = d * 10 * ppy, min((d + 1) * 10 * ppy, len(price_ret))
        if end > start:
            stats[f"decade_{d + 1}_vol"] = annualized_vol(price_ret[start:end], ppy)

    # --- Per-investor stats (loop, not copy-paste) ---
    total_final_w = sum(investors[name].wealth[-1] for name in CORE_INVESTORS)
    flow_scale = params.inout_vol / np.sqrt(ppy)

    for name in CORE_INVESTORS:
        inv = investors[name]
        w, s = inv.wealth, inv.shares

        # Average equity allocation
        eq_alloc = np.where(w > 0, s * market.price / w, 0.0)
        stats[f"{name}_avg_equity"] = float(np.mean(eq_alloc))

        # Wealth returns (strip out cash flows for investors that receive them)
        flow_fn = FLOW_SHOCKS.get(name)
        if flow_fn:
            flows = flow_fn(shocks)[1:] * flow_scale * w[:-1]
            wret = np.where(w[:-1] > 0, (w[1:] - flows) / w[:-1] - 1, 0.0)
        else:
            wret = np.where(w[:-1] > 0, w[1:] / w[:-1] - 1, 0.0)

        stats[f"{name}_vol"] = annualized_vol(wret, ppy)
        stats[f"{name}_cagr"] = float(np.exp(np.sum(np.log1p(wret)) / years) - 1)
        stats[f"{name}_sharpe"] = sharpe_ratio(wret, rf_periodic, ppy)
        stats[f"{name}_final_wealth_pct"] = float(w[-1] / total_final_w) if total_final_w > 0 else 0.0

    # --- Trading volume ---
    total_volume = sum(
        np.sum(np.abs(np.diff(investors[name].shares))) for name in CORE_INVESTORS
    )
    avg_shares = float(np.mean(market.shares_outstanding))
    stats["avg_annual_volume"] = float(total_volume / years)
    stats["volume_ratio"] = stats["avg_annual_volume"] / avg_shares if avg_shares > 0 else 0.0
    stats["n_periods"] = float(n - 1)

    # --- Anticip investor stats ---
    if "anticip" in investors:
        inv = investors["anticip"]
        w, s = inv.wealth, inv.shares

        eq_alloc = np.where(w > 0, s * market.price / w, 0.0)
        stats["anticip_avg_equity"] = float(np.mean(eq_alloc))

        # Wealth returns (no flows)
        wret = np.where(w[:-1] > 0, w[1:] / w[:-1] - 1, 0.0)

        anticip_vol = annualized_vol(wret, ppy)
        stats["anticip_vol"] = anticip_vol
        stats["anticip_variance"] = anticip_vol ** 2
        stats["anticip_cagr"] = float(np.exp(np.sum(np.log1p(wret)) / years) - 1)
        stats["anticip_sharpe"] = sharpe_ratio(wret, rf_periodic, ppy)
        stats["anticip_wealth_multiple"] = float(w[-1] / params.anticip.initial_wealth)

    return stats


import pandas as pd


def display_statistics(
    stats: dict[str, float],
    investors: dict[str, InvestorState],
    title: str = "Simulation Statistics",
    show_se: bool = False,
):
    """Display statistics as formatted pandas tables."""

    def _pct(v):
        return f"{v:.2%}"

    def _f4(v):
        return f"{v:.4f}"

    def _f2(v):
        return f"{v:.2f}"

    def _val(key, fmt=_f4):
        v = stats.get(key)
        if v is None:
            return ""
        s = fmt(v)
        if show_se:
            se = stats.get(f"{key}_se")
            if se is not None:
                s += f" ({fmt(se)})"
        return s

    print(f"\n{'─' * 50}")
    print(f"  {title}")
    print(f"{'─' * 50}")

    # ── Returns & Yields ──
    returns_data = {
        "Price CAGR": _val("price_cagr", _pct),
        "Total Return CAGR": _val("tr_cagr", _pct),
        "TR Sharpe": _val("tr_sharpe"),
        "EY (10yr)": _val("ey_10yr", _pct),
        "EY (final)": _val("ey_final", _pct),
        "Real Rate (final)": _val("final_real_rate", _pct),
    }
    df = pd.DataFrame.from_dict(returns_data, orient="index", columns=["Value"])
    df.index.name = "Returns & Yields"
    display(df)

    # ── Volatility ──
    vol_data = {
        "Price Vol": _val("price_vol"),
        "Earnings Vol": _val("earnings_vol"),
        "Vol of Vol": _val("vol_of_vol"),
        "Vol Clustering": _val("vol_clustering"),
    }
    # Decade vols
    decade_keys = sorted(k for k in stats if k.startswith("decade_") and not k.endswith("_se"))
    for k in decade_keys:
        label = k.replace("decade_", "Decade ").replace("_vol", "")
        vol_data[label] = _val(k)
    df = pd.DataFrame.from_dict(vol_data, orient="index", columns=["Value"])
    df.index.name = "Volatility"
    display(df)

    # ── Drawdowns & Limits ──
    dd_data = {
        "Price Max DD": _val("price_max_dd", _pct),
        "TR Max DD": _val("tr_max_dd", _pct),
        "Earnings Max DD": _val("earnings_max_dd", _pct),
    }
    if "frac_max_up" in stats:
        dd_data["Frac at Price Ceiling"] = _val("frac_max_up", _pct)
        dd_data["Frac at Price Floor"] = _val("frac_max_down", _pct)
    df = pd.DataFrame.from_dict(dd_data, orient="index", columns=["Value"])
    df.index.name = "Drawdowns & Limits"
    display(df)

    # ── Investor Performance ──
    inv_names = list(CORE_INVESTORS)
    if "anticip" in investors:
        inv_names.append("anticip")
    rows = []
    for name in inv_names:
        rows.append({
            "Avg Equity %": _val(f"{name}_avg_equity", _pct),
            "Volatility": _val(f"{name}_vol"),
            "CAGR": _val(f"{name}_cagr", _pct),
            "Sharpe": _val(f"{name}_sharpe"),
            "Wealth %": _val(f"{name}_final_wealth_pct", _pct),
        })
    # Add anticip-specific columns if present
    if "anticip" in investors and "anticip_wealth_multiple" in stats:
        for i, name in enumerate(inv_names):
            if name == "anticip":
                rows[i]["Wealth Multiple"] = _val("anticip_wealth_multiple", _f2)
            else:
                rows[i]["Wealth Multiple"] = ""
    df = pd.DataFrame(rows, index=[n.capitalize() for n in inv_names])
    df.index.name = "Investor"
    display(df)

    # ── Trading Volume ──
    if "avg_annual_volume" in stats:
        vol_data = {
            "Avg Annual Volume": _val("avg_annual_volume", _f2),
            "Volume Ratio": _val("volume_ratio", _f2),
            "Periods": f"{int(stats['n_periods']):,}",
        }
        df = pd.DataFrame.from_dict(vol_data, orient="index", columns=["Value"])
        df.index.name = "Trading Volume"
        display(df)

"""## Plotting

Matplotlib visualizations of simulation results. Price and earnings-yield paths are
shown for multiple Monte Carlo runs. Three detailed charts from the first simulation
show equity allocations, yield/rate dynamics, and a dual-axis price/earnings view.

**Functions:**
- `plot_price_paths(all_results, params, max_paths)` -- overlay price trajectories
- `plot_earnings_yields(all_results, params, max_paths)` -- overlay earnings yield trajectories
- `plot_first_simulation(market, investors, params)` -- three detailed charts from one run
"""

# @title
# Plotting functions for simulation results.

import matplotlib.pyplot as plt


def plot_price_paths(
    all_results: list[tuple[MarketState, dict[str, InvestorState]]],
    params: SimulationParams,
    max_paths: int = 20,
):
    """Plot stock price paths from multiple simulations."""
    ppy = params.periods_per_year
    plt.figure(figsize=(12, 7))
    n = min(max_paths, len(all_results))
    for i in range(n):
        market, _ = all_results[i]
        time_years = np.arange(len(market.price)) / ppy
        plt.plot(time_years, market.price, alpha=0.7, linewidth=1.5)
    plt.xlabel("Years", fontsize=12)
    plt.ylabel("Stock Price", fontsize=12)
    plt.title(f"Stock Market Price Paths - First {n} Simulations", fontsize=14, fontweight="bold")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()
    plt.close()


def plot_earnings_yields(
    all_results: list[tuple[MarketState, dict[str, InvestorState]]],
    params: SimulationParams,
    max_paths: int = 20,
):
    """Plot earnings yield paths from multiple simulations."""
    ppy = params.periods_per_year
    plt.figure(figsize=(12, 7))
    n = min(max_paths, len(all_results))
    for i in range(n):
        market, _ = all_results[i]
        ey = market.earnings / market.price
        ey_annual_pct = ((1 + ey) ** ppy - 1) * 100
        time_years = np.arange(len(market.price)) / ppy
        plt.plot(time_years, ey_annual_pct, alpha=0.7, linewidth=1.5)
    plt.xlabel("Years", fontsize=12)
    plt.ylabel("Earnings Yield (%)", fontsize=12)
    plt.title(f"Earnings Yield Paths - First {n} Simulations", fontsize=14, fontweight="bold")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()
    plt.close()


def plot_first_simulation(
    market: MarketState,
    investors: dict[str, InvestorState],
    params: SimulationParams,
):
    """Plot three charts from a single simulation:
    1. Equity allocations for cashflow and extrap investors
    2. Earnings yield, risk premium, and real interest rate
    3. Stock price index (left) and earnings (right)
    """
    ppy = params.periods_per_year
    n = len(market.price)
    time_years = np.arange(n) / ppy

    # --- Precompute series ---
    cf = investors["cashflow"]
    ex = investors["extrap"]
    cf_equity_pct = np.where(
        cf.wealth > 0, cf.shares * market.price / cf.wealth * 100, 0.0
    )
    ex_equity_pct = np.where(
        ex.wealth > 0, ex.shares * market.price / ex.wealth * 100, 0.0
    )
    ey = (1 + market.earnings / market.price) ** ppy - 1
    rp = ey - market.real_rate

    # ===== Chart 1: Equity Allocations =====
    fig, ax = plt.subplots(figsize=(14, 8))
    bar_w = 1.5 / ppy
    ax.bar(
        time_years - bar_w * 0.5, cf_equity_pct, width=bar_w,
        label="Cashflow Investor Equity %", color="tab:gray", alpha=0.4, edgecolor="none",
    )
    ax.bar(
        time_years + bar_w * 0.5, ex_equity_pct, width=bar_w,
        label="Extrapolator Equity %", color="tab:green", alpha=0.4, edgecolor="none",
    )
    ax.set_xlabel("Years", fontsize=12)
    ax.set_ylabel("Equity Allocation (%)", fontsize=12)
    ax.set_title("Equity Allocations - First Simulation", fontsize=14, fontweight="bold")
    ax.legend(loc="best", fontsize=10)
    ax.grid(True, alpha=0.3)
    fig.tight_layout()
    plt.show()
    plt.close()

    # ===== Chart 2: Earnings Yield, Risk Premium, Real Rate =====
    plt.figure(figsize=(12, 7))
    plt.plot(time_years, ey * 100, label="Earnings Yield", color="tab:red", linewidth=2, alpha=0.8)
    plt.plot(time_years, rp * 100, label="Risk Premium", color="tab:orange", linewidth=2, linestyle="--", alpha=0.8)
    plt.plot(time_years, market.real_rate * 100, label="Real Interest Rate", color="tab:blue", linewidth=2, linestyle="-.", alpha=0.8)
    plt.xlabel("Years", fontsize=12)
    plt.ylabel("Percentage (%)", fontsize=12)
    plt.title("Earnings Yield, Risk Premium, and Real Rate - First Simulation", fontsize=14, fontweight="bold")
    plt.legend(loc="best", fontsize=10)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()
    plt.close()

    # ===== Chart 3: Price Index & Earnings (dual axis) =====
    fig, ax1 = plt.subplots(figsize=(12, 7))
    color1 = "tab:purple"
    ax1.set_xlabel("Years", fontsize=12)
    ax1.set_ylabel("Stock Price Index", fontsize=12, color=color1)
    line1 = ax1.plot(time_years, market.price, color=color1, linewidth=2.5, alpha=0.9, label="Price Index")
    ax1.tick_params(axis="y", labelcolor=color1)
    ax1.grid(True, alpha=0.3)

    ax2 = ax1.twinx()
    color2 = "tab:green"
    ax2.set_ylabel("Earnings", fontsize=12, color=color2)
    line2 = ax2.plot(time_years, market.earnings, color=color2, linewidth=2.5, alpha=0.9, label="Earnings")
    ax2.tick_params(axis="y", labelcolor=color2)

    lines = line1 + line2
    ax1.legend(lines, [l.get_label() for l in lines], loc="best", fontsize=10)
    plt.title("Stock Price Index and Earnings - First Simulation", fontsize=14, fontweight="bold")
    fig.tight_layout()
    plt.show()
    plt.close()

"""## Run Monte Carlo

Execute 50 simulations with default parameters, display averaged statistics with
standard errors.
"""

# @title
# Monte Carlo: run multiple simulations, display averaged statistics, and plot paths.
mc_params = SimulationParams()
avg_stats, all_stats, all_results = run_monte_carlo(mc_params, n_sims=50, base_seed=42)

# Use the investors dict from the first sim for column detection (anticip presence)
_, first_investors = all_results[0]
display_statistics(avg_stats, first_investors, title=f"Monte Carlo Averaged (N={len(all_stats)})", show_se=True)

"""## Plots
Plot price paths, earnings yields, and detailed first-simulation
charts.
"""

# @title
# Plot paths from first N simulations
plot_price_paths(all_results, mc_params, max_paths=20)
plot_earnings_yields(all_results, mc_params, max_paths=20)

# Plot detailed charts from first simulation
first_market, first_investors = all_results[0]
plot_first_simulation(first_market, first_investors, mc_params)

